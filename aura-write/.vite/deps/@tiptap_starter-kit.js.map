{
  "version": 3,
  "sources": ["../../node_modules/@tiptap/core/src/jsx-runtime.ts", "../../node_modules/@tiptap/extension-blockquote/src/blockquote.tsx", "../../node_modules/@tiptap/extension-blockquote/src/index.ts", "../../node_modules/@tiptap/extension-bold/src/bold.tsx", "../../node_modules/@tiptap/extension-bold/src/index.ts", "../../node_modules/@tiptap/extension-code/src/code.ts", "../../node_modules/@tiptap/extension-code/src/index.ts", "../../node_modules/@tiptap/extension-code-block/src/code-block.ts", "../../node_modules/@tiptap/extension-code-block/src/index.ts", "../../node_modules/@tiptap/extension-document/src/document.ts", "../../node_modules/@tiptap/extension-document/src/index.ts", "../../node_modules/@tiptap/extension-hard-break/src/hard-break.ts", "../../node_modules/@tiptap/extension-hard-break/src/index.ts", "../../node_modules/@tiptap/extension-heading/src/heading.ts", "../../node_modules/@tiptap/extension-heading/src/index.ts", "../../node_modules/@tiptap/extension-horizontal-rule/src/horizontal-rule.ts", "../../node_modules/@tiptap/extension-horizontal-rule/src/index.ts", "../../node_modules/@tiptap/extension-italic/src/italic.ts", "../../node_modules/@tiptap/extension-italic/src/index.ts", "../../node_modules/@tiptap/extension-list/src/bullet-list/bullet-list.ts", "../../node_modules/@tiptap/extension-list/src/item/list-item.ts", "../../node_modules/@tiptap/extension-list/src/keymap/list-keymap.ts", "../../node_modules/@tiptap/extension-list/src/keymap/listHelpers/index.ts", "../../node_modules/@tiptap/extension-list/src/keymap/listHelpers/findListItemPos.ts", "../../node_modules/@tiptap/extension-list/src/keymap/listHelpers/getNextListDepth.ts", "../../node_modules/@tiptap/extension-list/src/keymap/listHelpers/handleBackspace.ts", "../../node_modules/@tiptap/extension-list/src/keymap/listHelpers/hasListBefore.ts", "../../node_modules/@tiptap/extension-list/src/keymap/listHelpers/hasListItemBefore.ts", "../../node_modules/@tiptap/extension-list/src/keymap/listHelpers/listItemHasSubList.ts", "../../node_modules/@tiptap/extension-list/src/keymap/listHelpers/handleDelete.ts", "../../node_modules/@tiptap/extension-list/src/keymap/listHelpers/nextListIsDeeper.ts", "../../node_modules/@tiptap/extension-list/src/keymap/listHelpers/nextListIsHigher.ts", "../../node_modules/@tiptap/extension-list/src/keymap/listHelpers/hasListItemAfter.ts", "../../node_modules/@tiptap/extension-list/src/kit/index.ts", "../../node_modules/@tiptap/extension-list/src/ordered-list/ordered-list.ts", "../../node_modules/@tiptap/extension-list/src/ordered-list/utils.ts", "../../node_modules/@tiptap/extension-list/src/task-item/task-item.ts", "../../node_modules/@tiptap/extension-list/src/task-list/task-list.ts", "../../node_modules/@tiptap/extension-paragraph/src/paragraph.ts", "../../node_modules/@tiptap/extension-paragraph/src/index.ts", "../../node_modules/@tiptap/extension-strike/src/strike.ts", "../../node_modules/@tiptap/extension-strike/src/index.ts", "../../node_modules/@tiptap/extension-text/src/text.ts", "../../node_modules/@tiptap/extension-text/src/index.ts", "../../node_modules/@tiptap/extension-underline/src/underline.ts", "../../node_modules/@tiptap/extension-underline/src/index.ts", "../../node_modules/@tiptap/starter-kit/src/starter-kit.ts", "../../node_modules/@tiptap/starter-kit/src/index.ts"],
  "sourcesContent": ["export type Attributes = Record<string, any>\n\nexport type DOMOutputSpecElement = 0 | Attributes | DOMOutputSpecArray\n/**\n * Better describes the output of a `renderHTML` function in prosemirror\n * @see https://prosemirror.net/docs/ref/#model.DOMOutputSpec\n */\nexport type DOMOutputSpecArray =\n  | [string]\n  | [string, Attributes]\n  | [string, 0]\n  | [string, Attributes, 0]\n  | [string, Attributes, DOMOutputSpecArray | 0]\n  | [string, DOMOutputSpecArray]\n\n// JSX types for Tiptap's JSX runtime\n// These types only apply when using @jsxImportSource @tiptap/core\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace JSX {\n  export type Element = DOMOutputSpecArray\n  export interface IntrinsicElements {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    [key: string]: any\n  }\n  export interface ElementChildrenAttribute {\n    children: unknown\n  }\n}\n\nexport type JSXRenderer = (\n  tag: 'slot' | string | ((props?: Attributes) => DOMOutputSpecArray | DOMOutputSpecElement),\n  props?: Attributes,\n  ...children: JSXRenderer[]\n) => DOMOutputSpecArray | DOMOutputSpecElement\n\nexport function Fragment(props: { children: JSXRenderer[] }) {\n  return props.children\n}\n\nexport const h: JSXRenderer = (tag, attributes) => {\n  // Treat the slot tag as the Prosemirror hole to render content into\n  if (tag === 'slot') {\n    return 0\n  }\n\n  // If the tag is a function, call it with the props\n  if (tag instanceof Function) {\n    return tag(attributes)\n  }\n\n  const { children, ...rest } = attributes ?? {}\n\n  if (tag === 'svg') {\n    throw new Error('SVG elements are not supported in the JSX syntax, use the array syntax instead')\n  }\n\n  // Otherwise, return the tag, attributes, and children\n  return [tag, rest, children]\n}\n\n// See\n// https://esbuild.github.io/api/#jsx-import-source\n// https://www.typescriptlang.org/tsconfig/#jsxImportSource\n\nexport { h as createElement, h as jsx, h as jsxDEV, h as jsxs }\n", "/** @jsxImportSource @tiptap/core */\nimport { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nexport interface BlockquoteOptions {\n  /**\n   * HTML attributes to add to the blockquote element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blockQuote: {\n      /**\n       * Set a blockquote node\n       */\n      setBlockquote: () => ReturnType\n      /**\n       * Toggle a blockquote node\n       */\n      toggleBlockquote: () => ReturnType\n      /**\n       * Unset a blockquote node\n       */\n      unsetBlockquote: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a blockquote to a `>` as input.\n */\nexport const inputRegex = /^\\s*>\\s$/\n\n/**\n * This extension allows you to create blockquotes.\n * @see https://tiptap.dev/api/nodes/blockquote\n */\nexport const Blockquote = Node.create<BlockquoteOptions>({\n  name: 'blockquote',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'block+',\n\n  group: 'block',\n\n  defining: true,\n\n  parseHTML() {\n    return [{ tag: 'blockquote' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return (\n      <blockquote {...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)}>\n        <slot />\n      </blockquote>\n    )\n  },\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode('blockquote', undefined, helpers.parseChildren(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    // Use a single '>' prefix regardless of nesting level\n    // Nested blockquotes will add their own '>' prefix recursively\n    const prefix = '>'\n    const result: string[] = []\n\n    node.content.forEach(child => {\n      // Render each child node as an array so it gets processed properly\n      const childContent = h.renderChildren([child])\n      const lines = childContent.split('\\n')\n\n      const linesWithPrefix = lines.map(line => {\n        // Don't add prefix to empty lines\n        if (line.trim() === '') {\n          return prefix\n        }\n\n        // Nested blockquotes will already have their own prefixes\n        // We just need to add our own prefix at the start\n        return `${prefix} ${line}`\n      })\n\n      result.push(linesWithPrefix.join('\\n'))\n    })\n\n    // Add separator lines between children\n    return result.join(`\\n${prefix}\\n`)\n  },\n\n  addCommands() {\n    return {\n      setBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.wrapIn(this.name)\n        },\n      toggleBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.toggleWrap(this.name)\n        },\n      unsetBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.lift(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-b': () => this.editor.commands.toggleBlockquote(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Blockquote } from './blockquote.jsx'\n\nexport * from './blockquote.jsx'\n\nexport default Blockquote\n", "/** @jsxImportSource @tiptap/core */\nimport { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface BoldOptions {\n  /**\n   * HTML attributes to add to the bold element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bold: {\n      /**\n       * Set a bold mark\n       */\n      setBold: () => ReturnType\n      /**\n       * Toggle a bold mark\n       */\n      toggleBold: () => ReturnType\n      /**\n       * Unset a bold mark\n       */\n      unsetBold: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches bold text via `**` as input.\n */\nexport const starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/\n\n/**\n * Matches bold text via `**` while pasting.\n */\nexport const starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g\n\n/**\n * Matches bold text via `__` as input.\n */\nexport const underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/\n\n/**\n * Matches bold text via `__` while pasting.\n */\nexport const underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g\n\n/**\n * This extension allows you to mark text as bold.\n * @see https://tiptap.dev/api/marks/bold\n */\nexport const Bold = Mark.create<BoldOptions>({\n  name: 'bold',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'strong',\n      },\n      {\n        tag: 'b',\n        getAttrs: node => (node as HTMLElement).style.fontWeight !== 'normal' && null,\n      },\n      {\n        style: 'font-weight=400',\n        clearMark: mark => mark.type.name === this.name,\n      },\n      {\n        style: 'font-weight',\n        getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value as string) && null,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return (\n      <strong {...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)}>\n        <slot />\n      </strong>\n    )\n  },\n\n  markdownTokenName: 'strong',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'strong' token to bold mark\n    return helpers.applyMark('bold', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `**${h.renderChildren(node)}**`\n  },\n\n  addCommands() {\n    return {\n      setBold:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleBold:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetBold:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-b': () => this.editor.commands.toggleBold(),\n      'Mod-B': () => this.editor.commands.toggleBold(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: starInputRegex,\n        type: this.type,\n      }),\n      markInputRule({\n        find: underscoreInputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: starPasteRegex,\n        type: this.type,\n      }),\n      markPasteRule({\n        find: underscorePasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Bold } from './bold.jsx'\n\nexport * from './bold.jsx'\n\nexport default Bold\n", "import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface CodeOptions {\n  /**\n   * The HTML attributes applied to the code element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    code: {\n      /**\n       * Set a code mark\n       */\n      setCode: () => ReturnType\n      /**\n       * Toggle inline code\n       */\n      toggleCode: () => ReturnType\n      /**\n       * Unset a code mark\n       */\n      unsetCode: () => ReturnType\n    }\n  }\n}\n\n/**\n * Regular expressions to match inline code blocks enclosed in backticks.\n *  It matches:\n *     - An opening backtick, followed by\n *     - Any text that doesn't include a backtick (captured for marking), followed by\n *     - A closing backtick as the final character.\n *  This ensures that any text between backticks is formatted as code,\n *  regardless of the surrounding characters (exception being another backtick).\n */\nexport const inputRegex = /(^|[^`])`([^`]+)`(?!`)$/\n\n/**\n * Matches inline code while pasting.\n */\nexport const pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g\n\n/**\n * This extension allows you to mark text as inline code.\n * @see https://tiptap.dev/api/marks/code\n */\nexport const Code = Mark.create<CodeOptions>({\n  name: 'code',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  excludes: '_',\n\n  code: true,\n\n  exitable: true,\n\n  parseHTML() {\n    return [{ tag: 'code' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['code', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'codespan',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'codespan' token to code mark\n    // For codespan tokens, we use the raw text content, not tokens\n    return helpers.applyMark('code', [{ type: 'text', text: token.text || '' }])\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return `\\`${h.renderChildren(node.content)}\\``\n  },\n\n  addCommands() {\n    return {\n      setCode:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleCode:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetCode:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-e': () => this.editor.commands.toggleCode(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: pasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Code } from './code.js'\n\nexport * from './code.js'\n\nexport default Code\n", "import { mergeAttributes, Node, textblockTypeInputRule } from '@tiptap/core'\nimport { Plugin, PluginKey, Selection, TextSelection } from '@tiptap/pm/state'\n\nconst DEFAULT_TAB_SIZE = 4\n\nexport interface CodeBlockOptions {\n  /**\n   * Adds a prefix to language classes that are applied to code tags.\n   * @default 'language-'\n   */\n  languageClassPrefix: string | null | undefined\n  /**\n   * Define whether the node should be exited on triple enter.\n   * @default true\n   */\n  exitOnTripleEnter: boolean | null | undefined\n  /**\n   * Define whether the node should be exited on arrow down if there is no node after it.\n   * @default true\n   */\n  exitOnArrowDown: boolean | null | undefined\n  /**\n   * The default language.\n   * @default null\n   * @example 'js'\n   */\n  defaultLanguage: string | null | undefined\n  /**\n   * Enable tab key for indentation in code blocks.\n   * @default false\n   */\n  enableTabIndentation: boolean | null | undefined\n  /**\n   * The number of spaces to use for tab indentation.\n   * @default 4\n   */\n  tabSize: number | null | undefined\n  /**\n   * Custom HTML attributes that should be added to the rendered HTML tag.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    codeBlock: {\n      /**\n       * Set a code block\n       * @param attributes Code block attributes\n       * @example editor.commands.setCodeBlock({ language: 'javascript' })\n       */\n      setCodeBlock: (attributes?: { language: string }) => ReturnType\n      /**\n       * Toggle a code block\n       * @param attributes Code block attributes\n       * @example editor.commands.toggleCodeBlock({ language: 'javascript' })\n       */\n      toggleCodeBlock: (attributes?: { language: string }) => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a code block with backticks.\n */\nexport const backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/\n\n/**\n * Matches a code block with tildes.\n */\nexport const tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/\n\n/**\n * This extension allows you to create code blocks.\n * @see https://tiptap.dev/api/nodes/code-block\n */\nexport const CodeBlock = Node.create<CodeBlockOptions>({\n  name: 'codeBlock',\n\n  addOptions() {\n    return {\n      languageClassPrefix: 'language-',\n      exitOnTripleEnter: true,\n      exitOnArrowDown: true,\n      defaultLanguage: null,\n      enableTabIndentation: false,\n      tabSize: DEFAULT_TAB_SIZE,\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'text*',\n\n  marks: '',\n\n  group: 'block',\n\n  code: true,\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      language: {\n        default: this.options.defaultLanguage,\n        parseHTML: element => {\n          const { languageClassPrefix } = this.options\n\n          if (!languageClassPrefix) {\n            return null\n          }\n\n          const classNames = [...(element.firstElementChild?.classList || [])]\n          const languages = classNames\n            .filter(className => className.startsWith(languageClassPrefix))\n            .map(className => className.replace(languageClassPrefix, ''))\n          const language = languages[0]\n\n          if (!language) {\n            return null\n          }\n\n          return language\n        },\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'pre',\n        preserveWhitespace: 'full',\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'pre',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      [\n        'code',\n        {\n          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null,\n        },\n        0,\n      ],\n    ]\n  },\n\n  markdownTokenName: 'code',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.raw?.startsWith('```') === false && token.codeBlockStyle !== 'indented') {\n      return []\n    }\n\n    return helpers.createNode(\n      'codeBlock',\n      { language: token.lang || null },\n      token.text ? [helpers.createTextNode(token.text)] : [],\n    )\n  },\n\n  renderMarkdown: (node, h) => {\n    let output = ''\n    const language = node.attrs?.language || ''\n\n    if (!node.content) {\n      output = `\\`\\`\\`${language}\\n\\n\\`\\`\\``\n    } else {\n      const lines = [`\\`\\`\\`${language}`, h.renderChildren(node.content), '```']\n      output = lines.join('\\n')\n    }\n\n    return output\n  },\n\n  addCommands() {\n    return {\n      setCodeBlock:\n        attributes =>\n        ({ commands }) => {\n          return commands.setNode(this.name, attributes)\n        },\n      toggleCodeBlock:\n        attributes =>\n        ({ commands }) => {\n          return commands.toggleNode(this.name, 'paragraph', attributes)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection\n        const isAtStart = $anchor.pos === 1\n\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false\n        }\n\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes()\n        }\n\n        return false\n      },\n\n      // handle tab indentation\n      Tab: ({ editor }) => {\n        if (!this.options.enableTabIndentation) {\n          return false\n        }\n\n        const tabSize = this.options.tabSize ?? DEFAULT_TAB_SIZE\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if ($from.parent.type !== this.type) {\n          return false\n        }\n\n        const indent = ' '.repeat(tabSize)\n\n        if (empty) {\n          return editor.commands.insertContent(indent)\n        }\n\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection\n          const text = state.doc.textBetween(from, to, '\\n', '\\n')\n          const lines = text.split('\\n')\n          const indentedText = lines.map(line => indent + line).join('\\n')\n\n          tr.replaceWith(from, to, state.schema.text(indentedText))\n          return true\n        })\n      },\n\n      // handle shift+tab reverse indentation\n      'Shift-Tab': ({ editor }) => {\n        if (!this.options.enableTabIndentation) {\n          return false\n        }\n\n        const tabSize = this.options.tabSize ?? DEFAULT_TAB_SIZE\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if ($from.parent.type !== this.type) {\n          return false\n        }\n\n        if (empty) {\n          return editor.commands.command(({ tr }) => {\n            const { pos } = $from\n            const codeBlockStart = $from.start()\n            const codeBlockEnd = $from.end()\n\n            const allText = state.doc.textBetween(codeBlockStart, codeBlockEnd, '\\n', '\\n')\n            const lines = allText.split('\\n')\n\n            let currentLineIndex = 0\n            let charCount = 0\n            const relativeCursorPos = pos - codeBlockStart\n\n            for (let i = 0; i < lines.length; i += 1) {\n              if (charCount + lines[i].length >= relativeCursorPos) {\n                currentLineIndex = i\n                break\n              }\n              charCount += lines[i].length + 1\n            }\n\n            const currentLine = lines[currentLineIndex]\n            const leadingSpaces = currentLine.match(/^ */)?.[0] || ''\n            const spacesToRemove = Math.min(leadingSpaces.length, tabSize)\n\n            if (spacesToRemove === 0) {\n              return true\n            }\n\n            let lineStartPos = codeBlockStart\n            for (let i = 0; i < currentLineIndex; i += 1) {\n              lineStartPos += lines[i].length + 1\n            }\n\n            tr.delete(lineStartPos, lineStartPos + spacesToRemove)\n\n            const cursorPosInLine = pos - lineStartPos\n            if (cursorPosInLine <= spacesToRemove) {\n              tr.setSelection(TextSelection.create(tr.doc, lineStartPos))\n            }\n\n            return true\n          })\n        }\n\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection\n          const text = state.doc.textBetween(from, to, '\\n', '\\n')\n          const lines = text.split('\\n')\n          const reverseIndentText = lines\n            .map(line => {\n              const leadingSpaces = line.match(/^ */)?.[0] || ''\n              const spacesToRemove = Math.min(leadingSpaces.length, tabSize)\n              return line.slice(spacesToRemove)\n            })\n            .join('\\n')\n\n          tr.replaceWith(from, to, state.schema.text(reverseIndentText))\n          return true\n        })\n      },\n\n      // exit node on triple enter\n      Enter: ({ editor }) => {\n        if (!this.options.exitOnTripleEnter) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith('\\n\\n')\n\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false\n        }\n\n        return editor\n          .chain()\n          .command(({ tr }) => {\n            tr.delete($from.pos - 2, $from.pos)\n\n            return true\n          })\n          .exitCode()\n          .run()\n      },\n\n      // exit node on arrow down\n      ArrowDown: ({ editor }) => {\n        if (!this.options.exitOnArrowDown) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection, doc } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n\n        if (!isAtEnd) {\n          return false\n        }\n\n        const after = $from.after()\n\n        if (after === undefined) {\n          return false\n        }\n\n        const nodeAfter = doc.nodeAt(after)\n\n        if (nodeAfter) {\n          return editor.commands.command(({ tr }) => {\n            tr.setSelection(Selection.near(doc.resolve(after)))\n            return true\n          })\n        }\n\n        return editor.commands.exitCode()\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      textblockTypeInputRule({\n        find: backtickInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n      textblockTypeInputRule({\n        find: tildeInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // this plugin creates a code block for pasted content from VS Code\n      // we can also detect the copied code language\n      new Plugin({\n        key: new PluginKey('codeBlockVSCodeHandler'),\n        props: {\n          handlePaste: (view, event) => {\n            if (!event.clipboardData) {\n              return false\n            }\n\n            // don’t create a new code block within code blocks\n            if (this.editor.isActive(this.type.name)) {\n              return false\n            }\n\n            const text = event.clipboardData.getData('text/plain')\n            const vscode = event.clipboardData.getData('vscode-editor-data')\n            const vscodeData = vscode ? JSON.parse(vscode) : undefined\n            const language = vscodeData?.mode\n\n            if (!text || !language) {\n              return false\n            }\n\n            const { tr, schema } = view.state\n\n            // prepare a text node\n            // strip carriage return chars from text pasted as code\n            // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n            const textNode = schema.text(text.replace(/\\r\\n?/g, '\\n'))\n\n            // create a code block with the text node\n            // replace selection with the code block\n            tr.replaceSelectionWith(this.type.create({ language }, textNode))\n\n            if (tr.selection.$from.parent.type !== this.type) {\n              // put cursor inside the newly created code block\n              tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))))\n            }\n\n            // store meta information\n            // this is useful for other plugins that depends on the paste event\n            // like the paste rule plugin\n            tr.setMeta('paste', true)\n\n            view.dispatch(tr)\n\n            return true\n          },\n        },\n      }),\n    ]\n  },\n})\n", "import { CodeBlock } from './code-block.js'\n\nexport * from './code-block.js'\n\nexport default CodeBlock\n", "import { Node } from '@tiptap/core'\n\n/**\n * The default document node which represents the top level node of the editor.\n * @see https://tiptap.dev/api/nodes/document\n */\nexport const Document = Node.create({\n  name: 'doc',\n  topNode: true,\n  content: 'block+',\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n\\n')\n  },\n})\n", "import { Document } from './document.js'\n\nexport * from './document.js'\n\nexport default Document\n", "import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface HardBreakOptions {\n  /**\n   * Controls if marks should be kept after being split by a hard break.\n   * @default true\n   * @example false\n   */\n  keepMarks: boolean\n\n  /**\n   * HTML attributes to add to the hard break element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    hardBreak: {\n      /**\n       * Add a hard break\n       * @example editor.commands.setHardBreak()\n       */\n      setHardBreak: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to insert hard breaks.\n * @see https://www.tiptap.dev/api/nodes/hard-break\n */\nexport const HardBreak = Node.create<HardBreakOptions>({\n  name: 'hardBreak',\n\n  markdownTokenName: 'br',\n\n  addOptions() {\n    return {\n      keepMarks: true,\n      HTMLAttributes: {},\n    }\n  },\n\n  inline: true,\n\n  group: 'inline',\n\n  selectable: false,\n\n  linebreakReplacement: true,\n\n  parseHTML() {\n    return [{ tag: 'br' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['br', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  renderText() {\n    return '\\n'\n  },\n\n  renderMarkdown: () => `  \\n`,\n\n  parseMarkdown: () => {\n    return {\n      type: 'hardBreak',\n    }\n  },\n\n  addCommands() {\n    return {\n      setHardBreak:\n        () =>\n        ({ commands, chain, state, editor }) => {\n          return commands.first([\n            () => commands.exitCode(),\n            () =>\n              commands.command(() => {\n                const { selection, storedMarks } = state\n\n                if (selection.$from.parent.type.spec.isolating) {\n                  return false\n                }\n\n                const { keepMarks } = this.options\n                const { splittableMarks } = editor.extensionManager\n                const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n                return chain()\n                  .insertContent({ type: this.name })\n                  .command(({ tr, dispatch }) => {\n                    if (dispatch && marks && keepMarks) {\n                      const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n                      tr.ensureMarks(filteredMarks)\n                    }\n\n                    return true\n                  })\n                  .run()\n              }),\n          ])\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Enter': () => this.editor.commands.setHardBreak(),\n      'Shift-Enter': () => this.editor.commands.setHardBreak(),\n    }\n  },\n})\n", "import { HardBreak } from './hard-break.js'\n\nexport * from './hard-break.js'\n\nexport default HardBreak\n", "import { mergeAttributes, Node, textblockTypeInputRule } from '@tiptap/core'\n\n/**\n * The heading level options.\n */\nexport type Level = 1 | 2 | 3 | 4 | 5 | 6\n\nexport interface HeadingOptions {\n  /**\n   * The available heading levels.\n   * @default [1, 2, 3, 4, 5, 6]\n   * @example [1, 2, 3]\n   */\n  levels: Level[]\n\n  /**\n   * The HTML attributes for a heading node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    heading: {\n      /**\n       * Set a heading node\n       * @param attributes The heading attributes\n       * @example editor.commands.setHeading({ level: 1 })\n       */\n      setHeading: (attributes: { level: Level }) => ReturnType\n      /**\n       * Toggle a heading node\n       * @param attributes The heading attributes\n       * @example editor.commands.toggleHeading({ level: 1 })\n       */\n      toggleHeading: (attributes: { level: Level }) => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create headings.\n * @see https://www.tiptap.dev/api/nodes/heading\n */\nexport const Heading = Node.create<HeadingOptions>({\n  name: 'heading',\n\n  addOptions() {\n    return {\n      levels: [1, 2, 3, 4, 5, 6],\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'inline*',\n\n  group: 'block',\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return this.options.levels.map((level: Level) => ({\n      tag: `h${level}`,\n      attrs: { level },\n    }))\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    const hasLevel = this.options.levels.includes(node.attrs.level)\n    const level = hasLevel ? node.attrs.level : this.options.levels[0]\n\n    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'heading' token to heading node\n    // marked provides 'depth' property (1-6) for heading level\n    return helpers.createNode('heading', { level: token.depth || 1 }, helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    const level = node.attrs?.level ? parseInt(node.attrs.level as string, 10) : 1\n    const headingChars = '#'.repeat(level)\n\n    if (!node.content) {\n      return ''\n    }\n\n    // Use current context for proper joining/spacing\n    return `${headingChars} ${h.renderChildren(node.content)}`\n  },\n\n  addCommands() {\n    return {\n      setHeading:\n        attributes =>\n        ({ commands }) => {\n          if (!this.options.levels.includes(attributes.level)) {\n            return false\n          }\n\n          return commands.setNode(this.name, attributes)\n        },\n      toggleHeading:\n        attributes =>\n        ({ commands }) => {\n          if (!this.options.levels.includes(attributes.level)) {\n            return false\n          }\n\n          return commands.toggleNode(this.name, 'paragraph', attributes)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return this.options.levels.reduce(\n      (items, level) => ({\n        ...items,\n        ...{\n          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level }),\n        },\n      }),\n      {},\n    )\n  },\n\n  addInputRules() {\n    return this.options.levels.map(level => {\n      return textblockTypeInputRule({\n        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\\\s$`),\n        type: this.type,\n        getAttributes: {\n          level,\n        },\n      })\n    })\n  },\n})\n", "import { Heading } from './heading.js'\n\nexport * from './heading.js'\n\nexport default Heading\n", "import { canInsertNode, isNodeSelection, mergeAttributes, Node, nodeInputRule } from '@tiptap/core'\nimport { NodeSelection, TextSelection } from '@tiptap/pm/state'\n\nexport interface HorizontalRuleOptions {\n  /**\n   * The HTML attributes for a horizontal rule node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n  /**\n   * The default type to insert after the horizontal rule.\n   * @default \"paragraph\"\n   * @example \"heading\"\n   */\n  nextNodeType: string\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       * @example editor.commands.setHorizontalRule()\n       */\n      setHorizontalRule: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      nextNodeType: 'paragraph',\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'hr' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  markdownTokenName: 'hr',\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode('horizontalRule')\n  },\n\n  renderMarkdown: () => {\n    return '---'\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule:\n        () =>\n        ({ chain, state }) => {\n          // Check if we can insert the node at the current selection\n          if (!canInsertNode(state, state.schema.nodes[this.name])) {\n            return false\n          }\n\n          const { selection } = state\n          const { $to: $originTo } = selection\n\n          const currentChain = chain()\n\n          if (isNodeSelection(selection)) {\n            currentChain.insertContentAt($originTo.pos, {\n              type: this.name,\n            })\n          } else {\n            currentChain.insertContent({ type: this.name })\n          }\n\n          return (\n            currentChain\n              // set cursor after horizontal rule\n              .command(({ state: chainState, tr, dispatch }) => {\n                if (dispatch) {\n                  const { $to } = tr.selection\n                  const posAfter = $to.end()\n\n                  if ($to.nodeAfter) {\n                    if ($to.nodeAfter.isTextblock) {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1))\n                    } else if ($to.nodeAfter.isBlock) {\n                      tr.setSelection(NodeSelection.create(tr.doc, $to.pos))\n                    } else {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos))\n                    }\n                  } else {\n                    // add node after horizontal rule if it’s the end of the document\n                    const nodeType =\n                      chainState.schema.nodes[this.options.nextNodeType] || $to.parent.type.contentMatch.defaultType\n                    const node = nodeType?.create()\n\n                    if (node) {\n                      tr.insert(posAfter, node)\n                      tr.setSelection(TextSelection.create(tr.doc, posAfter + 1))\n                    }\n                  }\n\n                  tr.scrollIntoView()\n                }\n\n                return true\n              })\n              .run()\n          )\n        },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { HorizontalRule } from './horizontal-rule.js'\n\nexport * from './horizontal-rule.js'\n\nexport default HorizontalRule\n", "import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface ItalicOptions {\n  /**\n   * HTML attributes to add to the italic element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    italic: {\n      /**\n       * Set an italic mark\n       * @example editor.commands.setItalic()\n       */\n      setItalic: () => ReturnType\n      /**\n       * Toggle an italic mark\n       * @example editor.commands.toggleItalic()\n       */\n      toggleItalic: () => ReturnType\n      /**\n       * Unset an italic mark\n       * @example editor.commands.unsetItalic()\n       */\n      unsetItalic: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches an italic to a *italic* on input.\n */\nexport const starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/\n\n/**\n * Matches an italic to a *italic* on paste.\n */\nexport const starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g\n\n/**\n * Matches an italic to a _italic_ on input.\n */\nexport const underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/\n\n/**\n * Matches an italic to a _italic_ on paste.\n */\nexport const underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g\n\n/**\n * This extension allows you to create italic text.\n * @see https://www.tiptap.dev/api/marks/italic\n */\nexport const Italic = Mark.create<ItalicOptions>({\n  name: 'italic',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'em',\n      },\n      {\n        tag: 'i',\n        getAttrs: node => (node as HTMLElement).style.fontStyle !== 'normal' && null,\n      },\n      {\n        style: 'font-style=normal',\n        clearMark: mark => mark.type.name === this.name,\n      },\n      {\n        style: 'font-style=italic',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['em', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setItalic:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleItalic:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetItalic:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  markdownTokenName: 'em',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'em' token to italic mark\n    return helpers.applyMark('italic', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `*${h.renderChildren(node)}*`\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-i': () => this.editor.commands.toggleItalic(),\n      'Mod-I': () => this.editor.commands.toggleItalic(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: starInputRegex,\n        type: this.type,\n      }),\n      markInputRule({\n        find: underscoreInputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: starPasteRegex,\n        type: this.type,\n      }),\n      markPasteRule({\n        find: underscorePasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Italic } from './italic.js'\n\nexport * from './italic.js'\n\nexport default Italic\n", "import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface BulletListOptions {\n  /**\n   * The node name for the list items\n   * @default 'listItem'\n   * @example 'paragraph'\n   */\n  itemTypeName: string\n\n  /**\n   * HTML attributes to add to the bullet list element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting the list\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting the list\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bulletList: {\n      /**\n       * Toggle a bullet list\n       */\n      toggleBulletList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a bullet list to a dash or asterisk.\n */\nexport const bulletListInputRegex = /^\\s*([-+*])\\s$/\n\n/**\n * This extension allows you to create bullet lists.\n * This requires the ListItem extension\n * @see https://tiptap.dev/api/nodes/bullet-list\n * @see https://tiptap.dev/api/nodes/list-item.\n */\nexport const BulletList = Node.create<BulletListOptions>({\n  name: 'bulletList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [{ tag: 'ul' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list' || (token as any).ordered) {\n      return []\n    }\n\n    return {\n      type: 'bulletList',\n      content: token.items ? helpers.parseChildren(token.items) : [],\n    }\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleBulletList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: bulletListInputRegex,\n      type: this.type,\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName)\n        },\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n", "import { mergeAttributes, Node, renderNestedMarkdownContent } from '@tiptap/core'\n\nexport interface ListItemOptions {\n  /**\n   * The HTML attributes for a list item node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for bulletList nodes\n   * @default 'bulletList'\n   * @example 'myCustomBulletList'\n   */\n  bulletListTypeName: string\n\n  /**\n   * The node type for orderedList nodes\n   * @default 'orderedList'\n   * @example 'myCustomOrderedList'\n   */\n  orderedListTypeName: string\n}\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const ListItem = Node.create<ListItemOptions>({\n  name: 'listItem',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: 'bulletList',\n      orderedListTypeName: 'orderedList',\n    }\n  },\n\n  content: 'paragraph block*',\n\n  defining: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: 'li',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list_item',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list_item') {\n      return []\n    }\n\n    let content: any[] = []\n\n    if (token.tokens && token.tokens.length > 0) {\n      // Check if we have paragraph tokens (complex list items)\n      const hasParagraphTokens = token.tokens.some(t => t.type === 'paragraph')\n\n      if (hasParagraphTokens) {\n        // If we have paragraph tokens, parse them as block elements\n        content = helpers.parseChildren(token.tokens)\n      } else {\n        // Check if the first token is a text token with nested inline tokens\n        const firstToken = token.tokens[0]\n\n        if (firstToken && firstToken.type === 'text' && firstToken.tokens && firstToken.tokens.length > 0) {\n          // Parse the inline content from the text token\n          const inlineContent = helpers.parseInline(firstToken.tokens)\n\n          // Start with the paragraph containing the inline content\n          content = [\n            {\n              type: 'paragraph',\n              content: inlineContent,\n            },\n          ]\n\n          // If there are additional tokens after the first text token (like nested lists),\n          // parse them as block elements and add them\n          if (token.tokens.length > 1) {\n            const remainingTokens = token.tokens.slice(1)\n            const additionalContent = helpers.parseChildren(remainingTokens)\n            content.push(...additionalContent)\n          }\n        } else {\n          // Fallback: parse all tokens as block elements\n          content = helpers.parseChildren(token.tokens)\n        }\n      }\n    }\n\n    // Ensure we always have at least an empty paragraph\n    if (content.length === 0) {\n      content = [\n        {\n          type: 'paragraph',\n          content: [],\n        },\n      ]\n    }\n\n    return {\n      type: 'listItem',\n      content,\n    }\n  },\n\n  renderMarkdown: (node, h, ctx) => {\n    return renderNestedMarkdownContent(\n      node,\n      h,\n      (context: any) => {\n        if (context.parentType === 'bulletList') {\n          return '- '\n        }\n        if (context.parentType === 'orderedList') {\n          return `${context.index + 1}. `\n        }\n        // Fallback to bullet list for unknown parent types\n        return '- '\n      },\n      ctx,\n    )\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n  },\n})\n", "import { Extension } from '@tiptap/core'\n\nimport { handleBackspace, handleDelete } from './listHelpers/index.js'\n\nexport type ListKeymapOptions = {\n  /**\n   * An array of list types. This is used for item and wrapper list matching.\n   * @default []\n   * @example [{ itemName: 'listItem', wrapperNames: ['bulletList', 'orderedList'] }]\n   */\n  listTypes: Array<{\n    itemName: string\n    wrapperNames: string[]\n  }>\n}\n\n/**\n * This extension registers custom keymaps to change the behaviour of the backspace and delete keys.\n * By default Prosemirror keyhandling will always lift or sink items so paragraphs are joined into\n * the adjacent or previous list item. This extension will prevent this behaviour and instead will\n * try to join paragraphs from two list items into a single list item.\n * @see https://www.tiptap.dev/api/extensions/list-keymap\n */\nexport const ListKeymap = Extension.create<ListKeymapOptions>({\n  name: 'listKeymap',\n\n  addOptions() {\n    return {\n      listTypes: [\n        {\n          itemName: 'listItem',\n          wrapperNames: ['bulletList', 'orderedList'],\n        },\n        {\n          itemName: 'taskItem',\n          wrapperNames: ['taskList'],\n        },\n      ],\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Delete': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      Backspace: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Backspace': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n    }\n  },\n})\n", "export * from './findListItemPos.js'\nexport * from './getNextListDepth.js'\nexport * from './handleBackspace.js'\nexport * from './handleDelete.js'\nexport * from './hasListBefore.js'\nexport * from './hasListItemAfter.js'\nexport * from './hasListItemBefore.js'\nexport * from './listItemHasSubList.js'\nexport * from './nextListIsDeeper.js'\nexport * from './nextListIsHigher.js'\n", "import { getNodeType } from '@tiptap/core'\nimport type { NodeType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const findListItemPos = (typeOrName: string | NodeType, state: EditorState) => {\n  const { $from } = state.selection\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let currentNode = null\n  let currentDepth = $from.depth\n  let currentPos = $from.pos\n  let targetDepth: number | null = null\n\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth)\n\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth\n    } else {\n      currentDepth -= 1\n      currentPos -= 1\n    }\n  }\n\n  if (targetDepth === null) {\n    return null\n  }\n\n  return { $pos: state.doc.resolve(currentPos), depth: targetDepth }\n}\n", "import { getNodeAtPosition } from '@tiptap/core'\nimport type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\n\nexport const getNextListDepth = (typeOrName: string, state: EditorState) => {\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4)\n\n  return depth\n}\n", "import type { Editor } from '@tiptap/core'\nimport { isAtStartOfNode, isNodeActive } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { hasListBefore } from './hasListBefore.js'\nimport { hasListItemBefore } from './hasListItemBefore.js'\nimport { listItemHasSubList } from './listItemHasSubList.js'\n\nexport const handleBackspace = (editor: Editor, name: string, parentListTypes: string[]) => {\n  // this is required to still handle the undo handling\n  if (editor.commands.undoInputRule()) {\n    return true\n  }\n\n  // if the selection is not collapsed\n  // we can rely on the default backspace behavior\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false\n  }\n\n  // if the current item is NOT inside a list item &\n  // the previous item is a list (orderedList or bulletList)\n  // move the cursor into the list and delete the current item\n  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const { $anchor } = editor.state.selection\n\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1)\n\n    const listDescendants: Array<{ node: Node; pos: number }> = []\n\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({ node, pos })\n      }\n    })\n\n    const lastItem = listDescendants.at(-1)\n\n    if (!lastItem) {\n      return false\n    }\n\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1)\n\n    return editor\n      .chain()\n      .cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end())\n      .joinForward()\n      .run()\n  }\n\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the start of a node\n  // do nothing and proceed\n  if (!isAtStartOfNode(editor.state)) {\n    return false\n  }\n\n  const listItemPos = findListItemPos(name, editor.state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2)\n  const prevNode = $prev.node(listItemPos.depth)\n\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode)\n\n  // if the previous item is a list item and doesn't have a sublist, join the list items\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward()\n  }\n\n  // otherwise in the end, a backspace should\n  // always just lift the list item if\n  // joining / merging is not possible\n  return editor.chain().liftListItem(name).run()\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListBefore = (editorState: EditorState, name: string, parentListTypes: string[]) => {\n  const { $anchor } = editorState.selection\n\n  const previousNodePos = Math.max(0, $anchor.pos - 2)\n\n  const previousNode = editorState.doc.resolve(previousNodePos).node()\n\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false\n  }\n\n  return true\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemBefore = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - 2)\n\n  if ($targetPos.index() === 0) {\n    return false\n  }\n\n  if ($targetPos.nodeBefore?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n", "import { getNodeType } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const listItemHasSubList = (typeOrName: string, state: EditorState, node?: Node) => {\n  if (!node) {\n    return false\n  }\n\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let hasSubList = false\n\n  node.descendants(child => {\n    if (child.type === nodeType) {\n      hasSubList = true\n    }\n  })\n\n  return hasSubList\n}\n", "import type { Editor } from '@tiptap/core'\nimport { isAtEndOfNode, isNodeActive } from '@tiptap/core'\n\nimport { nextListIsDeeper } from './nextListIsDeeper.js'\nimport { nextListIsHigher } from './nextListIsHigher.js'\n\nexport const handleDelete = (editor: Editor, name: string) => {\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the end of a node\n  // do nothing and proceed\n  if (!isAtEndOfNode(editor.state, name)) {\n    return false\n  }\n\n  // if the selection is not collapsed, or not within a single node\n  // do nothing and proceed\n  const { selection } = editor.state\n  const { $from, $to } = selection\n\n  if (!selection.empty && $from.sameParent($to)) {\n    return false\n  }\n\n  // check if the next node is a list with a deeper depth\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor\n      .chain()\n      .focus(editor.state.selection.from + 4)\n      .lift(name)\n      .joinBackward()\n      .run()\n  }\n\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run()\n  }\n\n  return editor.commands.joinItemForward()\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsDeeper = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth > listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsHigher = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth < listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemAfter = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2)\n\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false\n  }\n\n  if ($targetPos.nodeAfter?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n", "import { Extension } from '@tiptap/core'\n\nimport type { BulletListOptions } from '../bullet-list/index.js'\nimport { BulletList } from '../bullet-list/index.js'\nimport type { ListItemOptions } from '../item/index.js'\nimport { ListItem } from '../item/index.js'\nimport type { ListKeymapOptions } from '../keymap/index.js'\nimport { ListKeymap } from '../keymap/index.js'\nimport type { OrderedListOptions } from '../ordered-list/index.js'\nimport { OrderedList } from '../ordered-list/index.js'\nimport type { TaskItemOptions } from '../task-item/index.js'\nimport { TaskItem } from '../task-item/index.js'\nimport type { TaskListOptions } from '../task-list/index.js'\nimport { TaskList } from '../task-list/index.js'\n\nexport interface ListKitOptions {\n  /**\n   * If set to false, the bulletList extension will not be registered\n   * @example table: false\n   */\n  bulletList: Partial<BulletListOptions> | false\n  /**\n   * If set to false, the listItem extension will not be registered\n   */\n  listItem: Partial<ListItemOptions> | false\n  /**\n   * If set to false, the listKeymap extension will not be registered\n   */\n  listKeymap: Partial<ListKeymapOptions> | false\n  /**\n   * If set to false, the orderedList extension will not be registered\n   */\n  orderedList: Partial<OrderedListOptions> | false\n  /**\n   * If set to false, the taskItem extension will not be registered\n   */\n  taskItem: Partial<TaskItemOptions> | false\n  /**\n   * If set to false, the taskList extension will not be registered\n   */\n  taskList: Partial<TaskListOptions> | false\n}\n\n/**\n * The table kit is a collection of table editor extensions.\n *\n * It’s a good starting point for building your own table in Tiptap.\n */\nexport const ListKit = Extension.create<ListKitOptions>({\n  name: 'listKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList))\n    }\n\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem))\n    }\n\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap))\n    }\n\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList))\n    }\n\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem))\n    }\n\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList))\n    }\n\n    return extensions\n  },\n})\n", "import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nimport { buildNestedStructure, collectOrderedListItems, parseListItems } from './utils.js'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface OrderedListOptions {\n  /**\n   * The node type name for list items.\n   * @default 'listItem'\n   * @example 'myListItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for an ordered list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    orderedList: {\n      /**\n       * Toggle an ordered list\n       * @example editor.commands.toggleOrderedList()\n       */\n      toggleOrderedList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\n */\nexport const orderedListInputRegex = /^(\\d+)\\.\\s$/\n\n/**\n * This extension allows you to create ordered lists.\n * This requires the ListItem extension\n * @see https://www.tiptap.dev/api/nodes/ordered-list\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const OrderedList = Node.create<OrderedListOptions>({\n  name: 'orderedList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => {\n          return element.hasAttribute('start') ? parseInt(element.getAttribute('start') || '', 10) : 1\n        },\n      },\n      type: {\n        default: null,\n        parseHTML: element => element.getAttribute('type'),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'ol',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes\n\n    return start === 1\n      ? ['ol', mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0]\n      : ['ol', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list' || !token.ordered) {\n      return []\n    }\n\n    const startValue = token.start || 1\n    const content = token.items ? parseListItems(token.items, helpers) : []\n\n    if (startValue !== 1) {\n      return {\n        type: 'orderedList',\n        attrs: { start: startValue },\n        content,\n      }\n    }\n\n    return {\n      type: 'orderedList',\n      content,\n    }\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'orderedList',\n    level: 'block',\n    start: (src: string) => {\n      const match = src.match(/^(\\s*)(\\d+)\\.\\s+/)\n      const index = match?.index\n      return index !== undefined ? index : -1\n    },\n    tokenize: (src: string, _tokens, lexer) => {\n      const lines = src.split('\\n')\n      const [listItems, consumed] = collectOrderedListItems(lines)\n\n      if (listItems.length === 0) {\n        return undefined\n      }\n\n      const items = buildNestedStructure(listItems, 0, lexer)\n\n      if (items.length === 0) {\n        return undefined\n      }\n\n      const startValue = listItems[0]?.number || 1\n\n      return {\n        type: 'list',\n        ordered: true,\n        start: startValue,\n        items,\n        raw: lines.slice(0, consumed).join('\\n'),\n      } as unknown as object\n    },\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleOrderedList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: match => ({ start: +match[1] }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: match => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName) }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n", "import type { JSONContent, MarkdownLexerConfiguration, MarkdownParseHelpers, MarkdownToken } from '@tiptap/core'\n\n/**\n * Matches an ordered list item line with optional leading whitespace.\n * Captures: (1) indentation spaces, (2) item number, (3) content after marker\n * Example matches: \"1. Item\", \"  2. Nested item\", \"    3. Deeply nested\"\n */\nconst ORDERED_LIST_ITEM_REGEX = /^(\\s*)(\\d+)\\.\\s+(.*)$/\n\n/**\n * Matches any line that starts with whitespace (indented content).\n * Used to identify continuation content that belongs to a list item.\n */\nconst INDENTED_LINE_REGEX = /^\\s/\n\n/**\n * Represents a parsed ordered list item with indentation information\n */\nexport interface OrderedListItem {\n  indent: number\n  number: number\n  content: string\n  raw: string\n}\n\n/**\n * Collects all ordered list items from lines, parsing them into a flat array\n * with indentation information. Stops collecting continuation content when\n * encountering nested list items, allowing them to be processed separately.\n *\n * @param lines - Array of source lines to parse\n * @returns Tuple of [listItems array, number of lines consumed]\n */\nexport function collectOrderedListItems(lines: string[]): [OrderedListItem[], number] {\n  const listItems: OrderedListItem[] = []\n  let currentLineIndex = 0\n  let consumed = 0\n\n  while (currentLineIndex < lines.length) {\n    const line = lines[currentLineIndex]\n    const match = line.match(ORDERED_LIST_ITEM_REGEX)\n\n    if (!match) {\n      break\n    }\n\n    const [, indent, number, content] = match\n    const indentLevel = indent.length\n    let itemContent = content\n    let nextLineIndex = currentLineIndex + 1\n    const itemLines = [line]\n\n    // Collect continuation lines for this item (but NOT nested list items)\n    while (nextLineIndex < lines.length) {\n      const nextLine = lines[nextLineIndex]\n      const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX)\n\n      // If it's another list item (nested or not), stop collecting\n      if (nextMatch) {\n        break\n      }\n\n      // Check for continuation content (non-list content)\n      if (nextLine.trim() === '') {\n        // Empty line\n        itemLines.push(nextLine)\n        itemContent += '\\n'\n        nextLineIndex += 1\n      } else if (nextLine.match(INDENTED_LINE_REGEX)) {\n        // Indented content - part of this item (but not a list item)\n        itemLines.push(nextLine)\n        itemContent += `\\n${nextLine.slice(indentLevel + 2)}` // Remove list marker indent\n        nextLineIndex += 1\n      } else {\n        // Non-indented line means end of list\n        break\n      }\n    }\n\n    listItems.push({\n      indent: indentLevel,\n      number: parseInt(number, 10),\n      content: itemContent.trim(),\n      raw: itemLines.join('\\n'),\n    })\n\n    consumed = nextLineIndex\n    currentLineIndex = nextLineIndex\n  }\n\n  return [listItems, consumed]\n}\n\n/**\n * Recursively builds a nested structure from a flat array of list items\n * based on their indentation levels. Creates proper markdown tokens with\n * nested lists where appropriate.\n *\n * @param items - Flat array of list items with indentation info\n * @param baseIndent - The indentation level to process at this recursion level\n * @param lexer - Markdown lexer for parsing inline and block content\n * @returns Array of list_item tokens with proper nesting\n */\nexport function buildNestedStructure(\n  items: OrderedListItem[],\n  baseIndent: number,\n  lexer: MarkdownLexerConfiguration,\n): unknown[] {\n  const result: unknown[] = []\n  let currentIndex = 0\n\n  while (currentIndex < items.length) {\n    const item = items[currentIndex]\n\n    if (item.indent === baseIndent) {\n      // This item belongs at the current level\n      const contentLines = item.content.split('\\n')\n      const mainText = contentLines[0]?.trim() || ''\n\n      const tokens = []\n\n      // Always wrap the main text in a paragraph token\n      if (mainText) {\n        tokens.push({\n          type: 'paragraph',\n          raw: mainText,\n          tokens: lexer.inlineTokens(mainText),\n        })\n      }\n\n      // Handle additional content after the main text\n      const additionalContent = contentLines.slice(1).join('\\n').trim()\n      if (additionalContent) {\n        // Parse as block tokens (handles mixed unordered lists, etc.)\n        const blockTokens = lexer.blockTokens(additionalContent)\n        tokens.push(...blockTokens)\n      }\n\n      // Look ahead to find nested items at deeper indent levels\n      let lookAheadIndex = currentIndex + 1\n      const nestedItems = []\n\n      while (lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent) {\n        nestedItems.push(items[lookAheadIndex])\n        lookAheadIndex += 1\n      }\n\n      // If we have nested items, recursively build their structure\n      if (nestedItems.length > 0) {\n        // Find the next indent level (immediate children)\n        const nextIndent = Math.min(...nestedItems.map(nestedItem => nestedItem.indent))\n\n        // Build the nested list recursively with all nested items\n        // The recursive call will handle further nesting\n        const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer)\n\n        // Create a nested list token\n        tokens.push({\n          type: 'list',\n          ordered: true,\n          start: nestedItems[0].number,\n          items: nestedListItems,\n          raw: nestedItems.map(nestedItem => nestedItem.raw).join('\\n'),\n        })\n      }\n\n      result.push({\n        type: 'list_item',\n        raw: item.raw,\n        tokens,\n      })\n\n      // Skip the nested items we just processed\n      currentIndex = lookAheadIndex\n    } else {\n      // This item has deeper indent than we're currently processing\n      // It should be handled by a recursive call\n      currentIndex += 1\n    }\n  }\n\n  return result\n}\n\n/**\n * Parses markdown list item tokens into Tiptap JSONContent structure,\n * ensuring text content is properly wrapped in paragraph nodes.\n *\n * @param items - Array of markdown tokens representing list items\n * @param helpers - Markdown parse helpers for recursive parsing\n * @returns Array of listItem JSONContent nodes\n */\nexport function parseListItems(items: MarkdownToken[], helpers: MarkdownParseHelpers): JSONContent[] {\n  return items.map(item => {\n    if (item.type !== 'list_item') {\n      return helpers.parseChildren([item])[0]\n    }\n\n    // Parse the tokens within the list item\n    const content: JSONContent[] = []\n\n    if (item.tokens && item.tokens.length > 0) {\n      item.tokens.forEach(itemToken => {\n        // If it's already a proper block node (paragraph, list, etc.), parse it directly\n        if (\n          itemToken.type === 'paragraph' ||\n          itemToken.type === 'list' ||\n          itemToken.type === 'blockquote' ||\n          itemToken.type === 'code'\n        ) {\n          content.push(...helpers.parseChildren([itemToken]))\n        } else if (itemToken.type === 'text' && itemToken.tokens) {\n          // If it's inline text tokens, wrap them in a paragraph\n          const inlineContent = helpers.parseChildren([itemToken])\n          content.push({\n            type: 'paragraph',\n            content: inlineContent,\n          })\n        } else {\n          // For any other content, try to parse it\n          const parsed = helpers.parseChildren([itemToken])\n          if (parsed.length > 0) {\n            content.push(...parsed)\n          }\n        }\n      })\n    }\n\n    return {\n      type: 'listItem',\n      content,\n    }\n  })\n}\n", "import type { KeyboardShortcutCommand } from '@tiptap/core'\nimport { mergeAttributes, Node, renderNestedMarkdownContent, wrappingInputRule } from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nexport interface TaskItemOptions {\n  /**\n   * A callback function that is called when the checkbox is clicked while the editor is in readonly mode.\n   * @param node The prosemirror node of the task item\n   * @param checked The new checked state\n   * @returns boolean\n   */\n  onReadOnlyChecked?: (node: ProseMirrorNode, checked: boolean) => boolean\n\n  /**\n   * Controls whether the task items can be nested or not.\n   * @default false\n   * @example true\n   */\n  nested: boolean\n\n  /**\n   * HTML attributes to add to the task item element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for taskList nodes\n   * @default 'taskList'\n   * @example 'myCustomTaskList'\n   */\n  taskListTypeName: string\n\n  /**\n   * Accessibility options for the task item.\n   * @default {}\n   * @example\n   * ```js\n   * {\n   *   checkboxLabel: (node) => `Task item: ${node.textContent || 'empty task item'}`\n   * }\n   */\n  a11y?: {\n    checkboxLabel?: (node: ProseMirrorNode, checked: boolean) => string\n  }\n}\n\n/**\n * Matches a task item to a - [ ] on input.\n */\nexport const inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/\n\n/**\n * This extension allows you to create task items.\n * @see https://www.tiptap.dev/api/nodes/task-item\n */\nexport const TaskItem = Node.create<TaskItemOptions>({\n  name: 'taskItem',\n\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: 'taskList',\n      a11y: undefined,\n    }\n  },\n\n  content() {\n    return this.options.nested ? 'paragraph block*' : 'paragraph+'\n  },\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: element => {\n          const dataChecked = element.getAttribute('data-checked')\n\n          return dataChecked === '' || dataChecked === 'true'\n        },\n        renderHTML: attributes => ({\n          'data-checked': attributes.checked,\n        }),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `li[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'li',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        'data-type': this.name,\n      }),\n      [\n        'label',\n        [\n          'input',\n          {\n            type: 'checkbox',\n            checked: node.attrs.checked ? 'checked' : null,\n          },\n        ],\n        ['span'],\n      ],\n      ['div', 0],\n    ]\n  },\n\n  parseMarkdown: (token, h) => {\n    // Parse the task item's text content into paragraph content\n    const content = []\n\n    // First, add the main paragraph content\n    if (token.tokens && token.tokens.length > 0) {\n      // If we have tokens, create a paragraph with the inline content\n      content.push(h.createNode('paragraph', {}, h.parseInline(token.tokens)))\n    } else if (token.text) {\n      // If we have raw text, create a paragraph with text node\n      content.push(h.createNode('paragraph', {}, [h.createNode('text', { text: token.text })]))\n    } else {\n      // Fallback: empty paragraph\n      content.push(h.createNode('paragraph', {}, []))\n    }\n\n    // Then, add any nested content (like nested task lists)\n    if (token.nestedTokens && token.nestedTokens.length > 0) {\n      const nestedContent = h.parseChildren(token.nestedTokens)\n      content.push(...nestedContent)\n    }\n\n    return h.createNode('taskItem', { checked: token.checked || false }, content)\n  },\n\n  renderMarkdown: (node, h) => {\n    const checkedChar = node.attrs?.checked ? 'x' : ' '\n    const prefix = `- [${checkedChar}] `\n\n    return renderNestedMarkdownContent(node, h, prefix)\n  },\n\n  addKeyboardShortcuts() {\n    const shortcuts: {\n      [key: string]: KeyboardShortcutCommand\n    } = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n\n    if (!this.options.nested) {\n      return shortcuts\n    }\n\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n    }\n  },\n\n  addNodeView() {\n    return ({ node, HTMLAttributes, getPos, editor }) => {\n      const listItem = document.createElement('li')\n      const checkboxWrapper = document.createElement('label')\n      const checkboxStyler = document.createElement('span')\n      const checkbox = document.createElement('input')\n      const content = document.createElement('div')\n\n      const updateA11Y = (currentNode: ProseMirrorNode) => {\n        checkbox.ariaLabel =\n          this.options.a11y?.checkboxLabel?.(currentNode, checkbox.checked) ||\n          `Task item checkbox for ${currentNode.textContent || 'empty task item'}`\n      }\n\n      updateA11Y(node)\n\n      checkboxWrapper.contentEditable = 'false'\n      checkbox.type = 'checkbox'\n      checkbox.addEventListener('mousedown', event => event.preventDefault())\n      checkbox.addEventListener('change', event => {\n        // if the editor isn’t editable and we don't have a handler for\n        // readonly checks we have to undo the latest change\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked\n\n          return\n        }\n\n        const { checked } = event.target as any\n\n        if (editor.isEditable && typeof getPos === 'function') {\n          editor\n            .chain()\n            .focus(undefined, { scrollIntoView: false })\n            .command(({ tr }) => {\n              const position = getPos()\n\n              if (typeof position !== 'number') {\n                return false\n              }\n              const currentNode = tr.doc.nodeAt(position)\n\n              tr.setNodeMarkup(position, undefined, {\n                ...currentNode?.attrs,\n                checked,\n              })\n\n              return true\n            })\n            .run()\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          // Reset state if onReadOnlyChecked returns false\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked\n          }\n        }\n      })\n\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      listItem.dataset.checked = node.attrs.checked\n      checkbox.checked = node.attrs.checked\n\n      checkboxWrapper.append(checkbox, checkboxStyler)\n      listItem.append(checkboxWrapper, content)\n\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: updatedNode => {\n          if (updatedNode.type !== this.type) {\n            return false\n          }\n\n          listItem.dataset.checked = updatedNode.attrs.checked\n          checkbox.checked = updatedNode.attrs.checked\n          updateA11Y(updatedNode)\n\n          return true\n        },\n      }\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          checked: match[match.length - 1] === 'x',\n        }),\n      }),\n    ]\n  },\n})\n", "import { mergeAttributes, Node, parseIndentedBlocks } from '@tiptap/core'\n\nexport interface TaskListOptions {\n  /**\n   * The node type name for a task item.\n   * @default 'taskItem'\n   * @example 'myCustomTaskItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for a task list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    taskList: {\n      /**\n       * Toggle a task list\n       * @example editor.commands.toggleTaskList()\n       */\n      toggleTaskList: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create task lists.\n * @see https://www.tiptap.dev/api/nodes/task-list\n */\nexport const TaskList = Node.create<TaskListOptions>({\n  name: 'taskList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'taskItem',\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `ul[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { 'data-type': this.name }), 0]\n  },\n\n  parseMarkdown: (token, h) => {\n    return h.createNode('taskList', {}, h.parseChildren(token.items || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'taskList',\n    level: 'block',\n    start(src) {\n      // Look for the start of a task list item\n      const index = src.match(/^\\s*[-+*]\\s+\\[([ xX])\\]\\s+/)?.index\n      return index !== undefined ? index : -1\n    },\n    tokenize(src, tokens, lexer) {\n      // Helper function to recursively parse task lists\n      const parseTaskListContent = (content: string): any[] | undefined => {\n        const nestedResult = parseIndentedBlocks(\n          content,\n          {\n            itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n            extractItemData: match => ({\n              indentLevel: match[1].length,\n              mainContent: match[4],\n              checked: match[3].toLowerCase() === 'x',\n            }),\n            createToken: (data, nestedTokens) => ({\n              type: 'taskItem',\n              raw: '',\n              mainContent: data.mainContent,\n              indentLevel: data.indentLevel,\n              checked: data.checked,\n              text: data.mainContent,\n              tokens: lexer.inlineTokens(data.mainContent),\n              nestedTokens,\n            }),\n            // Allow recursive nesting\n            customNestedParser: parseTaskListContent,\n          },\n          lexer,\n        )\n\n        if (nestedResult) {\n          // Return as task list token\n          return [\n            {\n              type: 'taskList',\n              raw: nestedResult.raw,\n              items: nestedResult.items,\n            },\n          ]\n        }\n\n        // Fall back to regular markdown parsing if not a task list\n        return lexer.blockTokens(content)\n      }\n\n      const result = parseIndentedBlocks(\n        src,\n        {\n          itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n          extractItemData: match => ({\n            indentLevel: match[1].length,\n            mainContent: match[4],\n            checked: match[3].toLowerCase() === 'x',\n          }),\n          createToken: (data, nestedTokens) => ({\n            type: 'taskItem',\n            raw: '',\n            mainContent: data.mainContent,\n            indentLevel: data.indentLevel,\n            checked: data.checked,\n            text: data.mainContent,\n            tokens: lexer.inlineTokens(data.mainContent),\n            nestedTokens,\n          }),\n          // Use the recursive parser for nested content\n          customNestedParser: parseTaskListContent,\n        },\n        lexer,\n      )\n\n      if (!result) {\n        return undefined\n      }\n\n      return {\n        type: 'taskList',\n        raw: result.raw,\n        items: result.items,\n      }\n    },\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleTaskList:\n        () =>\n        ({ commands }) => {\n          return commands.toggleList(this.name, this.options.itemTypeName)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-9': () => this.editor.commands.toggleTaskList(),\n    }\n  },\n})\n", "import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface ParagraphOptions {\n  /**\n   * The HTML attributes for a paragraph node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    paragraph: {\n      /**\n       * Toggle a paragraph\n       * @example editor.commands.toggleParagraph()\n       */\n      setParagraph: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create paragraphs.\n * @see https://www.tiptap.dev/api/nodes/paragraph\n */\nexport const Paragraph = Node.create<ParagraphOptions>({\n  name: 'paragraph',\n\n  priority: 1000,\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  content: 'inline*',\n\n  parseHTML() {\n    return [{ tag: 'p' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['p', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown: (token, helpers) => {\n    const tokens = token.tokens || []\n\n    // Special case: if paragraph contains only a single image token,\n    // unwrap it to avoid nesting block elements incorrectly\n    if (tokens.length === 1 && tokens[0].type === 'image') {\n      // Parse the image token directly as a block element\n      return helpers.parseChildren([tokens[0]])\n    }\n\n    // Convert 'paragraph' token to paragraph node\n    return helpers.createNode(\n      'paragraph',\n      undefined, // no attributes for paragraph\n      helpers.parseInline(tokens),\n    )\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node || !Array.isArray(node.content)) {\n      return ''\n    }\n\n    return h.renderChildren(node.content)\n  },\n\n  addCommands() {\n    return {\n      setParagraph:\n        () =>\n        ({ commands }) => {\n          return commands.setNode(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-0': () => this.editor.commands.setParagraph(),\n    }\n  },\n})\n", "import { Paragraph } from './paragraph.js'\n\nexport * from './paragraph.js'\n\nexport default Paragraph\n", "import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface StrikeOptions {\n  /**\n   * HTML attributes to add to the strike element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    strike: {\n      /**\n       * Set a strike mark\n       * @example editor.commands.setStrike()\n       */\n      setStrike: () => ReturnType\n      /**\n       * Toggle a strike mark\n       * @example editor.commands.toggleStrike()\n       */\n      toggleStrike: () => ReturnType\n      /**\n       * Unset a strike mark\n       * @example editor.commands.unsetStrike()\n       */\n      unsetStrike: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a strike to a ~~strike~~ on input.\n */\nexport const inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/\n\n/**\n * Matches a strike to a ~~strike~~ on paste.\n */\nexport const pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g\n\n/**\n * This extension allows you to create strike text.\n * @see https://www.tiptap.dev/api/marks/strike\n */\nexport const Strike = Mark.create<StrikeOptions>({\n  name: 'strike',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 's',\n      },\n      {\n        tag: 'del',\n      },\n      {\n        tag: 'strike',\n      },\n      {\n        style: 'text-decoration',\n        consuming: false,\n        getAttrs: style => ((style as string).includes('line-through') ? {} : false),\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['s', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'del',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'del' token to strike mark\n    return helpers.applyMark('strike', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `~~${h.renderChildren(node)}~~`\n  },\n\n  addCommands() {\n    return {\n      setStrike:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleStrike:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetStrike:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-s': () => this.editor.commands.toggleStrike(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: pasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Strike } from './strike.js'\n\nexport * from './strike.js'\n\nexport default Strike\n", "import { Node } from '@tiptap/core'\n\n/**\n * This extension allows you to create text nodes.\n * @see https://www.tiptap.dev/api/nodes/text\n */\nexport const Text = Node.create({\n  name: 'text',\n  group: 'inline',\n\n  parseMarkdown: token => {\n    // Convert 'text' token to text node - text nodes are special as they store text directly\n    return {\n      type: 'text',\n      text: token.text || '',\n    }\n  },\n\n  renderMarkdown: node => node.text || '',\n})\n", "import { Text } from './text.js'\n\nexport * from './text.js'\n\nexport default Text\n", "import { Mark, mergeAttributes } from '@tiptap/core'\n\nexport interface UnderlineOptions {\n  /**\n   * HTML attributes to add to the underline element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    underline: {\n      /**\n       * Set an underline mark\n       * @example editor.commands.setUnderline()\n       */\n      setUnderline: () => ReturnType\n      /**\n       * Toggle an underline mark\n       * @example editor.commands.toggleUnderline()\n       */\n      toggleUnderline: () => ReturnType\n      /**\n       * Unset an underline mark\n       * @example editor.commands.unsetUnderline()\n       */\n      unsetUnderline: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create underline text.\n * @see https://www.tiptap.dev/api/marks/underline\n */\nexport const Underline = Mark.create<UnderlineOptions>({\n  name: 'underline',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'u',\n      },\n      {\n        style: 'text-decoration',\n        consuming: false,\n        getAttrs: style => ((style as string).includes('underline') ? {} : false),\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['u', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown(token, helpers) {\n    return helpers.applyMark(this.name || 'underline', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown(node, helpers) {\n    return `++${helpers.renderChildren(node)}++`\n  },\n\n  markdownTokenizer: {\n    name: 'underline',\n    level: 'inline',\n    start(src) {\n      return src.indexOf('++')\n    },\n    tokenize(src, _tokens, lexer) {\n      const rule = /^(\\+\\+)([\\s\\S]+?)(\\+\\+)/\n      const match = rule.exec(src)\n\n      if (!match) {\n        return undefined\n      }\n\n      const innerContent = match[2].trim()\n\n      return {\n        type: 'underline',\n        raw: match[0],\n        text: innerContent,\n        tokens: lexer.inlineTokens(innerContent),\n      }\n    },\n  },\n\n  addCommands() {\n    return {\n      setUnderline:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleUnderline:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetUnderline:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-u': () => this.editor.commands.toggleUnderline(),\n      'Mod-U': () => this.editor.commands.toggleUnderline(),\n    }\n  },\n})\n", "import { Underline } from './underline.js'\n\nexport * from './underline.js'\n\nexport default Underline\n", "import { Extension } from '@tiptap/core'\nimport type { BlockquoteOptions } from '@tiptap/extension-blockquote'\nimport { Blockquote } from '@tiptap/extension-blockquote'\nimport type { BoldOptions } from '@tiptap/extension-bold'\nimport { Bold } from '@tiptap/extension-bold'\nimport type { CodeOptions } from '@tiptap/extension-code'\nimport { Code } from '@tiptap/extension-code'\nimport type { CodeBlockOptions } from '@tiptap/extension-code-block'\nimport { CodeBlock } from '@tiptap/extension-code-block'\nimport { Document } from '@tiptap/extension-document'\nimport type { HardBreakOptions } from '@tiptap/extension-hard-break'\nimport { HardBreak } from '@tiptap/extension-hard-break'\nimport type { HeadingOptions } from '@tiptap/extension-heading'\nimport { Heading } from '@tiptap/extension-heading'\nimport type { HorizontalRuleOptions } from '@tiptap/extension-horizontal-rule'\nimport { HorizontalRule } from '@tiptap/extension-horizontal-rule'\nimport type { ItalicOptions } from '@tiptap/extension-italic'\nimport { Italic } from '@tiptap/extension-italic'\nimport type { LinkOptions } from '@tiptap/extension-link'\nimport { Link } from '@tiptap/extension-link'\nimport type { BulletListOptions, ListItemOptions, ListKeymapOptions, OrderedListOptions } from '@tiptap/extension-list'\nimport { BulletList, ListItem, ListKeymap, OrderedList } from '@tiptap/extension-list'\nimport type { ParagraphOptions } from '@tiptap/extension-paragraph'\nimport { Paragraph } from '@tiptap/extension-paragraph'\nimport type { StrikeOptions } from '@tiptap/extension-strike'\nimport { Strike } from '@tiptap/extension-strike'\nimport { Text } from '@tiptap/extension-text'\nimport type { UnderlineOptions } from '@tiptap/extension-underline'\nimport { Underline } from '@tiptap/extension-underline'\nimport type { DropcursorOptions, TrailingNodeOptions, UndoRedoOptions } from '@tiptap/extensions'\nimport { Dropcursor, Gapcursor, TrailingNode, UndoRedo } from '@tiptap/extensions'\n\nexport interface StarterKitOptions {\n  /**\n   * If set to false, the blockquote extension will not be registered\n   * @example blockquote: false\n   */\n  blockquote: Partial<BlockquoteOptions> | false\n\n  /**\n   * If set to false, the bold extension will not be registered\n   * @example bold: false\n   */\n  bold: Partial<BoldOptions> | false\n\n  /**\n   * If set to false, the bulletList extension will not be registered\n   * @example bulletList: false\n   */\n  bulletList: Partial<BulletListOptions> | false\n\n  /**\n   * If set to false, the code extension will not be registered\n   * @example code: false\n   */\n  code: Partial<CodeOptions> | false\n\n  /**\n   * If set to false, the codeBlock extension will not be registered\n   * @example codeBlock: false\n   */\n  codeBlock: Partial<CodeBlockOptions> | false\n\n  /**\n   * If set to false, the document extension will not be registered\n   * @example document: false\n   */\n  document: false\n\n  /**\n   * If set to false, the dropcursor extension will not be registered\n   * @example dropcursor: false\n   */\n  dropcursor: Partial<DropcursorOptions> | false\n\n  /**\n   * If set to false, the gapcursor extension will not be registered\n   * @example gapcursor: false\n   */\n  gapcursor: false\n\n  /**\n   * If set to false, the hardBreak extension will not be registered\n   * @example hardBreak: false\n   */\n  hardBreak: Partial<HardBreakOptions> | false\n\n  /**\n   * If set to false, the heading extension will not be registered\n   * @example heading: false\n   */\n  heading: Partial<HeadingOptions> | false\n\n  /**\n   * If set to false, the undo-redo extension will not be registered\n   * @example undoRedo: false\n   */\n  undoRedo: Partial<UndoRedoOptions> | false\n\n  /**\n   * If set to false, the horizontalRule extension will not be registered\n   * @example horizontalRule: false\n   */\n  horizontalRule: Partial<HorizontalRuleOptions> | false\n\n  /**\n   * If set to false, the italic extension will not be registered\n   * @example italic: false\n   */\n  italic: Partial<ItalicOptions> | false\n\n  /**\n   * If set to false, the listItem extension will not be registered\n   * @example listItem: false\n   */\n  listItem: Partial<ListItemOptions> | false\n\n  /**\n   * If set to false, the listItemKeymap extension will not be registered\n   * @example listKeymap: false\n   */\n  listKeymap: Partial<ListKeymapOptions> | false\n\n  /**\n   * If set to false, the link extension will not be registered\n   * @example link: false\n   */\n  link: Partial<LinkOptions> | false\n\n  /**\n   * If set to false, the orderedList extension will not be registered\n   * @example orderedList: false\n   */\n  orderedList: Partial<OrderedListOptions> | false\n\n  /**\n   * If set to false, the paragraph extension will not be registered\n   * @example paragraph: false\n   */\n  paragraph: Partial<ParagraphOptions> | false\n\n  /**\n   * If set to false, the strike extension will not be registered\n   * @example strike: false\n   */\n  strike: Partial<StrikeOptions> | false\n\n  /**\n   * If set to false, the text extension will not be registered\n   * @example text: false\n   */\n  text: false\n\n  /**\n   * If set to false, the underline extension will not be registered\n   * @example underline: false\n   */\n  underline: Partial<UnderlineOptions> | false\n\n  /**\n   * If set to false, the trailingNode extension will not be registered\n   * @example trailingNode: false\n   */\n  trailingNode: Partial<TrailingNodeOptions> | false\n}\n\n/**\n * The starter kit is a collection of essential editor extensions.\n *\n * It’s a good starting point for building your own editor.\n */\nexport const StarterKit = Extension.create<StarterKitOptions>({\n  name: 'starterKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.bold !== false) {\n      extensions.push(Bold.configure(this.options.bold))\n    }\n\n    if (this.options.blockquote !== false) {\n      extensions.push(Blockquote.configure(this.options.blockquote))\n    }\n\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList))\n    }\n\n    if (this.options.code !== false) {\n      extensions.push(Code.configure(this.options.code))\n    }\n\n    if (this.options.codeBlock !== false) {\n      extensions.push(CodeBlock.configure(this.options.codeBlock))\n    }\n\n    if (this.options.document !== false) {\n      extensions.push(Document.configure(this.options.document))\n    }\n\n    if (this.options.dropcursor !== false) {\n      extensions.push(Dropcursor.configure(this.options.dropcursor))\n    }\n\n    if (this.options.gapcursor !== false) {\n      extensions.push(Gapcursor.configure(this.options.gapcursor))\n    }\n\n    if (this.options.hardBreak !== false) {\n      extensions.push(HardBreak.configure(this.options.hardBreak))\n    }\n\n    if (this.options.heading !== false) {\n      extensions.push(Heading.configure(this.options.heading))\n    }\n\n    if (this.options.undoRedo !== false) {\n      extensions.push(UndoRedo.configure(this.options.undoRedo))\n    }\n\n    if (this.options.horizontalRule !== false) {\n      extensions.push(HorizontalRule.configure(this.options.horizontalRule))\n    }\n\n    if (this.options.italic !== false) {\n      extensions.push(Italic.configure(this.options.italic))\n    }\n\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem))\n    }\n\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options?.listKeymap))\n    }\n\n    if (this.options.link !== false) {\n      extensions.push(Link.configure(this.options?.link))\n    }\n\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList))\n    }\n\n    if (this.options.paragraph !== false) {\n      extensions.push(Paragraph.configure(this.options.paragraph))\n    }\n\n    if (this.options.strike !== false) {\n      extensions.push(Strike.configure(this.options.strike))\n    }\n\n    if (this.options.text !== false) {\n      extensions.push(Text.configure(this.options.text))\n    }\n\n    if (this.options.underline !== false) {\n      extensions.push(Underline.configure(this.options?.underline))\n    }\n\n    if (this.options.trailingNode !== false) {\n      extensions.push(TrailingNode.configure(this.options?.trailingNode))\n    }\n\n    return extensions\n  },\n})\n", "import { StarterKit } from './starter-kit.js'\n\nexport type { StarterKitOptions } from './starter-kit.js'\nexport * from './starter-kit.js'\n\nexport default StarterKit\n"],
  "mappings": "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",
  "names": ["h", "h", "inputRegex", "h", "h", "_a", "h", "h", "starInputRegex", "starPasteRegex", "underscoreInputRegex", "underscorePasteRegex", "h", "h", "Node", "mergeAttributes", "getNodeType", "isNodeActive", "ListItemName", "TextStyleName", "wrappingInputRule", "inputRegex", "renderNestedMarkdownContent", "Extension", "h", "inputRegex", "pasteRegex", "h"]
}
